# Welcome to Python Essentials 2

## Module 1: **Modules, Packages and PIP**

# How to make use of a module?

So what is a module? The [Python Tutorial](https://docs.python.org/3/tutorial/modules.html) defines it as **a file containing Python definitions and statements**, which can be later imported and used when necessary.

The handling of modules consists of two different issues:

- the first (probably the most common) happens when you want to use an already existing module, written by someone else, or created by yourself during your work on some complex project - in this case you are the module's **user**;
- the second occurs when you want to create a brand new module, either for your own use, or to make other programmers' lives easier - you are the module's **supplier**.

**Import modules**

A **namespace** is a space (understood in a non-physical context) in which some names exist and the names don't conflict with each other (i.e., there are not two different objects of the same name). We can say that each social group is a namespace - the group tends to name each of its members in a unique way (e.g., parents won't give their children the same first names).

```python
pi = 3.14

def sin(x):
    if 2 * x == pi:
        return 0.99999999
    else:
        return None

print(sin(pi / 2))
>>> 0.9999

from math import sin, pi

print(sin(pi / 2))
>>> 1.0
```

Here, we've reversed the sequence of the code's operations:

- lines 1 through 8: define our own `pi` and `sin`;
- line 11: make use of them (`0.99999999` appears on the screen)
- line 13: carry out the import - the imported symbols **supersede their previous definitions within the namespace**;
- line 15: get `1.0` as a result.

#### Using alias

```python
from math import pi as PI, sin as sine

print(sine(PI/2))
```

# Is there real randomness in computers?

Another module worth mentioning is the one named `random`.

It delivers some mechanisms allowing you to operate with **pseudorandom numbers**.

Note the prefix **pseudo** - the numbers generated by the modules may look random in the sense that you cannot predict their subsequent values, but don't forget that they all are calculated using very refined algorithms.

The algorithms aren't random - they are deterministic and predictable. Only those physical processes which run completely out of our control (like the intensity of cosmic radiation) may be used as a source of actual random data. Data produced by deterministic computers cannot be random in any way.

```python
from random import randrange, randint

print(randrange(1), end=' ')
0
print(randrange(0, 1), end=' ')
0
print(randrange(0, 1, 1), end=' ')
0
print(randint(0, 1))
1
```

### **The choice and sample functions**

As you can see, this is not a good tool for generating numbers in a lottery. Fortunately, there is a better solution than writing your own code to check the uniqueness of the "drawn" numbers.

It's a function named in a very suggestive way - `choice`:

- `choice(sequence)`
- `sample(sequence, elements_to_choose)`

The first variant chooses a "random" element from the input sequence and returns it.

The second one builds a list (a sample) consisting of the `elements_to_choose` element "drawn" from the input sequence.

Look at the code below:

```python
from random import choice, 
sample my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 
print(choice(my_list)) 
print(sample(my_list, 5))
print(sample(my_list, 10)) 
```

Again, the output of the program is not predictable. Our results looked like this:

```python
4 
[3, 1, 8, 9, 10] 
[10, 8, 5, 1, 6, 4, 3, 9, 7, 2]
```

## Package

Let's summarize some important issues:

- a **module is a kind of container filled with functions** - you can pack as many functions as you want into one module and distribute it across the world;
- of course, it's generally a good idea not to mix functions with different application areas within one module (just like in a library - nobody expects scientific works to be put among comic books), so group your functions carefully and name the module containing them in a clear and intuitive way (e.g., don't give the name `arcade_games` to a module containing functions intended to partition and format hard disks)
- making many modules may cause a little mess - sooner or later you'll want to **group your modules** exactly in the same way as you've previously grouped functions - is there a more general container than a module?
- yes, there is - it's a **package**; in the world of modules, a package plays a similar role to a folder/directory in the world of files.

You can only inform your users that this is your variable, that they may read it, but that they should not modify it under any circumstances.

This is done by preceding the variable's name with `_` (one underscore) or `__` (two underscores), but remember, it's only a **convention**. Your module's users may obey it or they may not.

------

A Python file named `__init__.py` is implicitly run when a package containing it is subject to import, and is used to initialize a package and/or its sub-packages (if any). The file may be empty, but must not be absent.

Some additional and necessary packages are stored inside the `D:\Python\Project\Modules` directory. Write a code ensuring that the directory is traversed by Python in order to find all requested modules.

```python
import sys # note the double backslashes! sys.path.append("D:\\Python\\Project\\Modules")
```

The directory mentioned in the previous exercise contains a sub-tree of the following structure:

```
abc 
	|__ def
    		|__ mymodule.py 
```

Assuming that `D:\Python\Project\Modules` has been successfully appended to the `sys.path` list, write an import directive letting you use all the `mymodule` entities.

```python
import abc.def.mymodule
```

We can say that:

- when you run a file directly, its `__name__` variable is set to `__main__`;
- when a file is imported as a module, its `__name__` variable is set to the file's name (excluding .py)

## PIP

 List of main **pip** activities looks as follows:

- `pip help *operation*` - shows brief pip's description;
- `pip list` - shows list of currently installed packages;
- `pip show *package_name*` - shows *package_name* info including package's dependencies;
- `pip search *anystring*` - searches through PyPI directories in order to find packages which name contains *anystring*;
- `pip install *name*` - installs *name* system-wide (expect problems when you don't have administrative rights);
- `pip install --user *name*` - install *name* for you only; no other your platform's user will be able to use it;
- `pip install -U *name*` - updates previously installed package;
- `pip uninstall *name*` - uninstalls previously installed package;

# Single characters

The one named **ASCII** (short for **American Standard Code for Information Interchange**) is the most widely used, and you can assume that nearly all modern devices (like computers, printers, mobile phones, tablets, etc.) use that code.

The code provides space for **256 different characters**, but we are interested only in the first 128. If you want to see how the code is constructed, look at the table below. Click the table to enlarge it. Look at it carefully - there are some interesting facts. Look at the code of the most common character - the *space*. This is *32*.

The **software I18N** is a standard in present times. Each program has to be written in a way that enables it to be used all around the world, among different cultures, languages and alphabets.

**A classic form of ASCII code uses eight bits for each sign**. Eight bits mean 256 different characters. The first 128 are used for the standard Latin alphabet (both upper-case and lower-case characters). Is it possible to push all the other national characters used around the world into the remaining 128 locations?

No. It isn't.

A code page is a **standard for using the upper 128 code points to store specific national characters**. For example, there are different code pages for Western Europe and Eastern Europe, Cyrillic and Greek alphabets, Arabic and Hebrew languages, and so on.

#### The name comes from **Universal Character Set**.

**UCS-4 uses 32 bits (four bytes) to store each character**, and the code is just the Unicode code points' unique number. A file containing UCS-4 encoded text may start with a BOM (byte order mark), an unprintable combination of bits announcing the nature of the file's contents. Some utilities may require it.

#### UTF-8

One of the most commonly used is **UTF-8**.

The name is derived from **Unicode Transformation Format**.

The concept is very smart. **UTF-8 uses as many bits for each of the code points as it really needs to represent them**.

For example:

- all Latin characters (and all standard ASCII characters) occupy eight bits;
- non-Latin characters occupy 16 bits;
- CJK (China-Japan-Korea) ideographs occupy 24 bits.

Due to features of the method used by UTF-8 to store the code points, there is no need to use the BOM, but some of the tools look for it when reading the file, and many editors set it up during the save.

### Strings

#### Operations on strings

Like other kinds of data, strings have their own set of permissible operations, although they're rather limited compared to numbers.

In general, strings can be:

- **concatenated** (joined)
- **replicated**.

The first operation is performed by the `+` operator (note: it's not an addition) while the second by the `*` operator (note again: it's not a multiplication).

##### ord()

If you want **to know a specific character's ASCII/UNICODE code point value**, you can use a function named `ord()` (as in *ordinal*).

##### chr()

If you know the code point (number) and want to get the corresponding character, you can use a function named `chr()`.

##### Iteration

```python
the_string = 'silly walks'

for character in the_string:
    print(character, end=' ')

print()
```

##### The in and not in operators

```python
alphabet = "abcdefghijklmnopqrstuvwxyz"

print("f" in alphabet)
print("F" in alphabet)

print("ghi" not in alphabet)
print("Xyz" not in alphabet)
```

##### Python strings are immutable, don’t use: del, insert, append

We've also told you that Python's **strings are immutable**. This is a very important feature. What does it mean?

This primarily means that the similarity of strings and lists is limited. Not everything you can do with a list may be done with a string.

The first important difference **doesn't allow you to use the `del` instruction to remove anything from a string**.

##### index()

The `index()` method (it's a method, not a function) **searches the sequence from the beginning, in order to find the first element of the value specified in its argument**.

```python
print("aAbByYzZaA".index("b"))
>>> 2
print("aAbByYzZaA".index("Z"))
>>> 7
```

##### List and count

```python
# Demonstrating the list() function:
print(list("abcabc"))
>>> ['a', 'b', 'c', 'a', 'b', 'c']
# Demonstrating the count() method:
print("abcabc".count("b"))
print('abcabc'.count("d"))
>>> 2
>>> 0
```

### String methods

#### capitalize()

The `capitalize()` method does exactly what it says - **it creates a new string filled with characters taken from the source string**, but it tries to modify them in the following way:

- **if the first character inside the string is a letter** (note: the first character is an element with an index equal to 0, not just the first visible character), **it will be converted to upper-case**;
- **all remaining letters from the string will be converted to lower-case**.

#### center()

The one-parameter variant of the `center()` method makes a copy of the original string, trying to center it inside a field of a specified width.

The centering is actually done by **adding some spaces before and after the string**.

```python
print('[' + 'gamma'.center(20, '*') + ']')
```

#### endswith()

The `endswith()` method **checks if the given string ends with the specified argument and returns `True` or `False`**, depending on the check result.

#### find()

The `find()` method is similar to `index()`, which you already know - **it looks for a substring and returns the index of first occurrence of this substring**, but:

- it's safer - it **doesn't generate an error for an argument containing a non-existent substring** (it returns `-1` then)
- it **works with strings only** - don't try to apply it to any other sequence.

#### The isalnum() method

The parameterless method named `isalnum()` **checks if the string contains only digits or alphabetical characters (letters), and returns `True` or `False`** according to the result.

#### The isalpha() method

The `isalpha()` method is more specialized - it's interested in **letters only**.

Look at Example 1 - its output is:

```python
print("Moooo".isalpha())
print('Mu40'.isalpha())
True False
```

#### The isdigit() method

In turn, the `isdigit()` method looks at **digits only** - anything else produces `False` as the result.

Look at Example 2 - its output is:

```python
# Example 2: Demonstrating the isdigit() method:
print('2018'.isdigit())
print("Year2019".isdigit())
True False
```

#### The islower() method

The `islower()` method is a fussy variant of `isalpha()` - it accepts **lower-case letters only**.

#### The isspace() method

The `isspace()` method **identifies whitespaces only** - it disregards any other character (the result is `False` then).

#### The isupper() method

The `isupper()` method is the upper-case version of `islower()` - it concentrates on **upper-case letters only**.

#### The join() method

The `join()` method is rather complicated, so let us guide you step by step thorough it:

- as its name suggests, the method **performs a join** - it expects one argument as a list; it must be assured that all the list's elements are strings - the method will raise a TypeError exception otherwise;

- all the list's elements will be **joined into one string** but...

- ...the string from which the method has been invoked is **used as a separator**, put among the strings;

- the newly created string is returned as a result.

  ```python
  # Demonstrating the join() method:
  print(",".join(["omicron", "pi", "rho"]))
  
  omicron,pi,rho
  ```

#### The lower() method

The `lower()` method **makes a copy of a source string, replaces all upper-case letters with their lower-case counterparts**, and returns the string as the result. Again, the source string remains untouched.

#### The lstrip() method

The parameterless `lstrip()` method **returns a newly created string formed from the original one by removing all leading whitespaces** from the left of the variable.

#### The rstrip() method

Two variants of the `rstrip()` method do nearly the same as `lstrip`s, but **affect the opposite side of the string**.

## The strip() method

The `strip()` method combines the effects caused by `rstrip()` and `lstrip()` - it **makes a new string lacking all the leading and trailing whitespaces**.

### The replace() method

The **two-parameter** `replace()` method **returns a copy of the original string in which all occurrences of the first argument have been replaced by the second argument**.

```python
# Demonstrating the replace() method:
print("www.netacad.com".replace("netacad.com", "pythoninstitute.org"))
print("This is it!".replace("is", "are"))
print("Apple juice".replace("juice", "
```

#### The rfind() method

The one-, two-, and three-parameter methods named `rfind()` do nearly the same things as their counterparts (the ones devoid of the *r* prefix), but **start their searches from the end of the string**, not the beginning (hence the prefix *r*, for *right*).

#### The split() method

The `split()` method does what it says - it **splits the string and builds a list of all detected substrings**.

The method **assumes that the substrings are delimited by whitespaces** - the spaces don't take part in the operation, and aren't copied into the resulting list.

#### The swapcase() method

The `swapcase()` method **makes a new string by swapping the case of all letters within the source string**: lower-case characters become upper-case, and vice versa.

## The title() method

The `title()` method performs a somewhat similar function - it **changes every word's first letter to upper-case, turning all other ones to lower-case**.

## Sorting

In general, Python offers two different ways to sort lists.

* The first is implemented as **a function named `sorted()`**.

The function takes one argument (a list) and **returns a new list**, filled with the sorted argument's elements. (Note: this description is a bit simplified compared to the actual implementation - we'll discuss it later.)

The original list remains untouched.

* The second method affects the list itself - **no new list is created**. Ordering is performed in situ by the method named `sort()`.

# Errors, failures, and other plagues

ValueError: math domain error `sqrt(-1)`

ZeroDivisionError: division by zero

IndexError: list index out of range `list[0]`

```python
first_number = int(input("Enter the first number: "))
second_number = int(input("Enter the second number: "))

if second_number != 0:
    print(first_number / second_number)
else:
    print("This operation cannot be done.")

print("THE END.")
```

 Look at the code in the editor. This is the favorite Python approach.

**Note:**

- the `try` keyword **begins a block of the code** which may or may not be performing correctly;
- next, Python tries to perform the risky action; if it fails, an exception is raised and Python starts to look for a solution;
- the `except` keyword starts a piece of code which will be **executed if anything inside the `try` block goes wrong** - if an exception is raised inside a previous `try` block, **it will fail here**, so the code located after the except keyword should provide an **adequate reaction** to the raised exception;
- returning to the previous nesting level ends the **try-except** section.

## Exceptions

Take a look at the figure:

![Tree-shaped hierarchy of selected exceptions](https://edube.org/uploads/media/default/0001/01/0ee75473d85349d36925771423976c94c08ddbf1.png)



It shows a small section of the complete exception tree. Let's begin examining the tree from the ZeroDivisionError leaf.

**Note**:

- ZeroDivisionError is a special case of more a general exception class named ArithmeticError;
- ArithmeticError is a special case of a more general exception class named just Exception;
- Exception is a special case of a more general class named BaseException;

We can describe it in the following way (note the direction of the arrows - they always point to the more general entity):

BaseException
↑
Exception
↑
ArithmeticError
↑
ZeroDivisionError

We're going to show you how this generalization works. Let's start with some really simple code.

This also means that replacing the exception's name with either `Exception` or `BaseException` won't change the program's behavior.

# Exceptions

Now is a good moment to show you another Python instruction, named `assert`. This is a keyword.

```
assert expression 
```

How does it work?

- It evaluates the expression;
- if the expression evaluates to `True`, or a non-zero numerical value, or a non-empty string, or any other value different than `None`, it won't do anything else;
- otherwise, it automatically and immediately raises an exception named AssertionError (in this case, we say that the assertion has failed)

How it can be used?

- you may want to put it into your code where you want to be **absolutely safe from evidently wrong data**, and where you aren't absolutely sure that the data has been carefully examined before (e.g., inside a function used by someone else)
- raising an AssertionError exception secures your code from producing invalid results, and clearly shows the nature of the failure;
- **assertions don't supersede exceptions or validate the data** - they are their supplements.

If exceptions and data validation are like careful driving, assertion can play the role of an airbag.

# **Object-Oriented Programming**

The **object approach** suggests a completely different way of thinking. The data and the code are enclosed together in the same world, divided into classes.

Every **class is like a recipe which can be used when you want to create a useful object** (this is where the name of the approach comes from). You may produce as many objects as you need to solve your problem.

Every object has a set of traits (they are called properties or attributes - we'll use both words synonymously) and is able to perform a set of activities (which are called methods).

The recipes may be modified if they are inadequate for specific purposes and, in effect, new classes may be created. These new classes inherit properties and methods from the originals, and usually add some new ones, creating new, more specific tools.

There is no clear border between data and code: they live as one in objects.

All these concepts are not as abstract as you may at first suspect. On the contrary, they all are taken from real-life experiences, and therefore are extremely useful in computer programming: they don't create artificial life - **they reflect real facts, relationships, and circumstances**.

### Class hierarchies

The word *class* has many meanings, but not all of them are compatible with the ideas we want to discuss here. The *class* that we are concerned with is like a *category*, as a result of precisely defined similarities.

We'll try to point out a few classes which are good examples of this concept.

![The concept of class hierarchies: vehicles](https://edube.org/uploads/media/default/0001/01/09e4ad95eae46acc8e0f6427751452cbd255b004.png)

Let's look for a moment at vehicles. All existing vehicles (and those that don't exist yet) are **related by a single, important feature**: the ability to move. You may argue that a dog moves, too; is a dog a vehicle? No, it isn't. We have to improve the definition, i.e., enrich it with other criteria, distinguishing vehicles from other beings, and creating a stronger connection. Let's take the following circumstances into consideration: vehicles are artificially created entities used for transportation, moved by forces of nature, and directed (driven) by humans.

Based on this definition, a dog is not a vehicle.

The *vehicles* class is very broad. Too broad. We have to define some more **specialized classes**, then. The specialized classes are the **subclasses**. The *vehicles* class will be a **superclass** for them all.

Note: **the hierarchy grows from top to bottom, like tree roots, not branches**. The most general, and the widest, class is always at the top (the superclass) while its descendants are located below (the subclasses).

By now, you can probably point out some potential subclasses for the *Vehicles* superclass. There are many possible classifications. We've chosen subclasses based on the environment, and say that there are (at least) four subclasses:

- land vehicles;
- water vehicles;
- air vehicles;
- space vehicles.

In this example, we'll discuss the first subclass only - land vehicles. If you wish, you can continue with the remaining classes.

Land vehicles may be further divided, depending on the method with which they impact the ground. So, we can enumerate:

- wheeled vehicles;
- tracked vehicles;
- hovercrafts.

The hierarchy we've created is illustrated by the figure.

Note the direction of the arrows - they always point to the superclass. The top-level class is an exception - it doesn't have its own superclass.

### What is an object?

A class (among other definitions) is a **set of objects**. An object is **a being belonging to a class**.

An object is **an incarnation of the requirements, traits, and qualities assigned to a specific class**. This may sound simple, but note the following important circumstances. Classes form a hierarchy.

This may mean that an object belonging to a specific class belongs to all the superclasses at the same time. It may also mean that any object belonging to a superclass may not belong to any of its subclasses.

For example: any personal car is an object belonging to the *wheeled vehicles* class. It also means that the same car belongs to all superclasses of its home class; therefore, it is a member of the *vehicles* class, too.

Each **subclass is more specialized** (or more specific) than its superclass. Conversely, each **superclass is more general** (more abstract) than any of its subclasses.

## Inheritance

Let's define one of the fundamental concepts of object programming, named **inheritance**. Any object bound to a specific level of a class hierarchy **inherits all the traits (as well as the requirements and qualities) defined inside any of the superclasses**.

The object's home class may define new traits (as well as requirements and qualities) which will be inherited by any of its subclasses.

![The inheritance concept](https://edube.org/uploads/media/default/0001/01/a099081349764cfda3d91329ee4a3345643802d4.png)

### What does an object have?

The object programming convention assumes that **every existing object may be equipped with three groups of attributes**:

- an object has a **name** that uniquely identifies it within its home namespace (although there may be some anonymous objects, too)
- an object has a **set of individual properties** which make it original, unique or outstanding (although it's possible that some objects may have no properties at all)
- an object has a **set of abilities to perform specific activities**, able to change the object itself, or some of the other objects.

There is a hint (although this doesn't always work) which can help you identify any of the three spheres above. Whenever you describe an object and you use:

- a noun - you probably define the object's name;
- an adjective - you probably define the object's property;
- a verb - you probably define the object's activity.

![The concept of object attributes](https://edube.org/uploads/media/default/0001/01/be95ffa57008024fff0e6cd735afa5687c806902.png)

### Your first class

Object programming is **the art of defining and expanding classes**. A class is a model of a very specific part of reality, reflecting properties and activities found in the real world.

The classes defined at the beginning are too general and imprecise to cover the largest possible number of real cases.

There's no obstacle to defining new, more precise subclasses. They'll inherit everything from their superclass, so the work that went into its creation isn't wasted.

The new class may add new properties and new activities, and therefore may be more useful in specific applications. Obviously, it may be used as a superclass for any number of newly created subclasses.

The process doesn't need to have an end. You can create as many classes as you need.

The class you define has nothing to do with the object: **the existence of a class does not mean that any of the compatible objects will automatically be created**. The class itself isn't able to create an object - you have to create it yourself, and Python allows you to do this.

```python
class TheSimplestClass:
    pass
```

## What is a stack?

**A stack is a structure developed to store data in a very specific way**. Imagine a stack of coins. You aren't able to put a coin anywhere else but on the top of the stack.

Similarly, you can't get a coin off the stack from any place other than the top of the stack. If you want to get the coin that lies on the bottom, you have to remove all the coins from the higher levels.

The alternative name for a stack (but only in IT terminology) is **LIFO**.

The stack itself is already created:

```
stack = []
```

#### An object approach

Such a function is called a **constructor**, as its general purpose is to **construct a new object**. The constructor should know everything about the object's structure, and must perform all the needed initializations.

- the constructor's name is always `__init__`;
- it has to have **at least one parameter** (we'll discuss this later); the parameter is used to represent the newly created object - you can use the parameter to manipulate the object, and to enrich it with the needed properties; you'll make use of this soon;
- note: the obligatory parameter is usually named `self` - it's only **a convention, but you should follow it** - it simplifies the process of reading and understanding your code.

1. Now let's **add just one property to the new object** - a list for a stack. We'll name it `stack_list`.

2. When any class component has a **name starting with two underscores (`__`), it becomes private** - this means that it can be accessed only from within the class.

​		You cannot see it from the outside world. This is how Python implements 		the **encapsulation** concept.

```python
lass Stack:
    def __init__(self):
        self.__stack_list = []

    def push(self, val):
        self.__stack_list.append(val)

    def pop(self):
        val = self.__stack_list[-1]
        del self.__stack_list[-1]
        return val


stack_object = Stack()

stack_object.push(3)
stack_object.push(2)
stack_object.push(1)

print(stack_object.pop())
print(stack_object.pop())
```

Here, both functions have a parameter named `self` at the first position of the parameters list.

Is it needed? Yes, it is.

All methods have to have this parameter. It plays the same role as the first constructor parameter.

**It allows the method to access entities (properties and activities/methods) carried out by the actual object**. You cannot omit it. Every time Python invokes a method, it implicitly sends the current object as the first argument.

This means that a **method is obligated to have at least one parameter, which is used by Python itself** - you don't have any influence on it.

### Subclasses

```python
class Stack:
    def __init__(self):
        self.__stack_list = []

    def push(self, val):
        self.__stack_list.append(val)

    def pop(self):
        val = self.__stack_list[-1]
        del self.__stack_list[-1]
        return val


class AddingStack(Stack):
    def __init__(self):
        Stack.__init__(self)
        self.__sum = 0
```

The class doesn't define any new component yet, but that doesn't mean that it's empty. **It gets all the components defined by its superclass** - the name of the superclass is written before the colon directly after the new class name.

## Instance variables

In general, a class can be equipped with two different kinds of data to form a class's properties. You already saw one of them when we were looking at stacks.

This kind of class property exists when and only when it is explicitly created and added to an object. As you already know, this can be done during the object's initialization, performed by the constructor.

```python
class ExampleClass:
    def __init__(self, val = 1):
        self.first = val

    def set_second(self, val):
        self.second = val


example_object_1 = ExampleClass()
example_object_2 = ExampleClass(2)

example_object_2.set_second(3)

example_object_3 = ExampleClass(4)
example_object_3.third = 5

print(example_object_1.__dict__)
print(example_object_2.__dict__)
print(example_object_3.__dict__)
```

It's nearly the same as the previous one. The only difference is in the property names. We've **added two underscores (`__`)** in front of them.

As you know, such an addition makes the instance variable **private** - it becomes inaccessible from the outer world.

#### Class variables

Look:

- there is an assignment in the first list of the class definition - it sets the variable named `counter` to 0; initializing the variable inside the class but outside any of its methods makes the variable a class variable;
- accessing such a variable looks the same as accessing any instance attribute - you can see it in the constructor body; as you can see, the constructor increments the variable by one; in effect, the variable counts all the created objects.

```python
class ExampleClass:
    counter = 0
    def __init__(self, val = 1):
        self.__first = val
        ExampleClass.counter += 1

example_object_1 = ExampleClass()
example_object_2 = ExampleClass(2)
example_object_3 = ExampleClass(4)

print(example_object_1.__dict__, example_object_1.counter)
print(example_object_2.__dict__, example_object_2.counter)
print(example_object_3.__dict__, example_object_3.counter)
```

#### Checking an attribute's

Python provides a **function which is able to safely check if any object/class contains a specified property**. The function is named `hasattr`, and expects two arguments to be passed to it:

- the class or the object being checked;
- the name of the property whose existence has to be reported (note: it has to be a string containing the attribute name, not the name alone)

The function returns True or False.

```python
class ExampleClass:
    def __init__(self, val):
        if val % 2 != 0:
            self.a = 1
        else:
            self.b = 1

example_object = ExampleClass(1)
print(example_object.a)

if hasattr(example_object, 'b'):
    print(example_object.b)
```

### Summary

```python
class Sample:
    gamma = 0 # Class variable.
    def __init__(self):
        self.alpha = 1 # Instance variable.
        self.__delta = 3 # Private instance variable.

obj = Sample()
obj.beta = 2  # Another instance variable (existing only inside the "obj" instance.)
print(obj.__dict__)
```

# Methods in detail

The first (or only) parameter is usually named `self`. We suggest that you follow the convention - it's commonly used, and you'll cause a few surprises by using other names for it.

The name self suggests the parameter's purpose - **it identifies the object for which the method is invoked**.

If you're going to invoke a method, you mustn't pass the argument for the `self` parameter - Python will set it for you.

```python
class Classy:
    def method(self, par):
        print("method:", par)

obj = Classy()
obj.method(1)
obj.method(2)
obj.method(3)
```

The `self` parameter is also used **to invoke other object/class methods from inside the class**.

Just like here:

```python
class Classy:
    def other(self):
        print("other")

    def method(self):
        print("method")
        self.other()

obj = Classy()
obj.method()
```

#### Access to hidden values

```python
class Classy:
    def visible(self):
        print("visible")
    
    def __hidden(self):
        print("hidden")


obj = Classy()
obj.visible()

try:
    obj.__hidden()
except:
    print("failed")

obj._Classy__hidden()
```

#### The inner life of classes and objects: continued

`__dict__` is a dictionary. Another built-in property worth mentioning is `__name__`, which is a string.

The property contains **the name of the class**. It's nothing exciting, just a string.

Note: the `__name__` attribute is absent from the object - **it exists only inside classes**.

If you want to **find the class of a particular object**, you can use a function named `type()`, which is able (among other things) to find a class which has been used to instantiate any object.

```python
class Classy:
    pass

print(Classy.__name__)
obj = Classy()
print(type(obj).__name__)
```

As you know, any module named `__main__` is actually not a module, but the **file currently being run**.

### Reflection and introspection

All these means allow the Python programmer to perform two important activities specific to many objective languages. They are:

- **introspection**, which is the ability of a program to examine the type or properties of an object at runtime;
- **reflection**, which goes a step further, and is the ability of a program to manipulate the values, properties and/or functions of an object at runtime.

In other words, you don't have to know a complete class/object definition to manipulate the object, as the object and/or its class contain the metadata allowing you to recognize its features during program execution.

## Key takeaways

1. A method is a function embedded inside a class. The first (or only) parameter of each method is usually named `self`, which is designed to identify the object for which the method is invoked in order to access the object's properties or invoke its methods.

2. If a class contains a **constructor** (a method named `__init__`) it cannot return any value and cannot be invoked directly.

3. All classes (but not objects) contain a property named `__name__`, which stores the name of the class. Additionally, a property named `__module__` stores the name of the module in which the class has been declared, while the property named `__bases__` is a tuple containing a class's superclasses.

```python
class Sample:
    def __init__(self):
        self.name = Sample.__name__
    def myself(self):
        print("My name is " + self.name + " living in a " + Sample.__module__)


obj = Sample()
obj.myself()
```

# Inheritance

Inheritance is a common practice (in object programming) of **passing attributes and methods from the superclass (defined and existing) to a newly created class, called the subclass**.

In other words, inheritance is **a way of building a new class, not from scratch, but by using an already defined repertoire of traits**. The new class inherits (and this is the key) all the already existing equipment, but is able to add some new ones if needed.

Thanks to that, it's possible to **build more specialized (more concrete) classes** using some sets of predefined general rules and behaviors.

```python
class Vehicle:
    pass

class LandVehicle(Vehicle):
    pass

class TrackedVehicle(LandVehicle):
    pass
```

We can say that:

- The `Vehicle` class is the superclass for both the `LandVehicle` and `TrackedVehicle` classes;
- The `LandVehicle` class is a subclass of `Vehicle` and a superclass of `TrackedVehicle` at the same time;
- The `TrackedVehicle` class is a subclass of both the `Vehicle` and `LandVehicle` classes.

###### `issubclass()`

Python offers a function which is able to **identify a relationship between two classes**, and although its diagnosis isn't complex, it can **check if a particular class is a subclass of any other class**.

```python
issubclass(ClassOne, ClassTwo)
```

The function returns True if `ClassOne` is a subclass of `ClassTwo`, and False otherwise.

###### `isinstance()`

As you already know, **an object is an incarnation of a class**. This means that the object is like a cake baked using a recipe which is included inside the class.

```python
isinstance(objectName, ClassName)
```

**Being an instance of a class means that the object (the cake) has been prepared using a recipe contained in either the class or one of its superclasses**.

###### the `is` operator

**The `is` operator checks whether two variables (`object_one` and `object_two` here) refer to the same object**.

```python
object_one is object_two
```

It can be said that:

- **inheritance extends a class's capabilities** by adding new components and modifying existing ones; in other words, the complete recipe is contained inside the class itself and all its ancestors; the object takes all the class's belongings and makes use of them;
- **composition projects a class as a container** able to store and use other objects (derived from other classes) where each of the objects implements a part of a desired class's behavior.

```
import time

class Tracks:
    def change_direction(self, left, on):
        print("tracks: ", left, on)


class Wheels:
    def change_direction(self, left, on):
        print("wheels: ", left, on)


class Vehicle:
    def __init__(self, controller):
        self.controller = controller

    def turn(self, left):
        self.controller.change_direction(left, True)
        time.sleep(0.25)
        self.controller.change_direction(left, False)


wheeled = Vehicle(Wheels())
tracked = Vehicle(Tracks())

wheeled.turn(True)
tracked.turn(False)

```

Vehicle uses as a controller, Tracks and Wheels

## Polymorphism

```python
class One:
    def do_it(self):
        print("do_it from One")

    def doanything(self):
        self.do_it()


class Two(One):
    def do_it(self):
        print("do_it from Two")


one = One()
two = Two()

one.doanything()
two.doanything()

>>>do_it from One
>>>do_it from Two

```

### What is Method Resolution Order (MRO) 

MRO, in general, is a way (you can call it a **strategy**) in which a particular programming language scans through the upper part of a class’s hierarchy in order to find the method it currently needs. It's worth emphasizing that different languages use slightly (or even completely) different MROs. Python is a unique creature in this respect, however, and its customs are a bit specific.

From the bottom to the top of the code

```python
class Top:
    def m_top(self):
        print("top")


class Middle(Top):
    def m_middle(self):
        print("middle")


class Bottom(Middle, Top):
# si cambia a (Top, Middle) no corre y error MRO
    def m_bottom(self):
        print("bottom")


object = Bottom()
object.m_bottom()
object.m_middle()
object.m_top()
```

### Key takeaways

1. A method named `__str__()` is responsible for **converting an object's contents into a (more or less) readable string**.

2. A function named `issubclass(Class_1, Class_2)` is able to determine if `Class_1` is   **subclass** of `Class_2`

3. A function named `isinstance(Object, Class)` checks if an object **comes from an indicated class**. 

4. A operator called `is` checks if two variables refer to **the same object**.

5. A parameterless function named `super()` returns a **reference to the nearest superclass of the class**.

6. Methods as well as instance and class variables defined in a superclass are **automatically inherited** by their subclasses. For example:

   ```
   class Mouse:
       Population = 0
       def __init__(self, name):
           Mouse.Population += 1
           self.name = name
   
       def __str__(self):
           return "Hi, my name is " + self.name
   
   class LabMouse(Mouse):
       pass
   
   professor_mouse = LabMouse("Professor Mouser")
   print(professor_mouse, Mouse.Population) 
   # Prints "Hi, my name is Professor Mouser 1"
   ```

7. If any of the subclasses defines a method/class variable/instance variable of the same name as existing in the superclass, the new name **overrides** any of the previous instances of the name.

# PART IV

## Generators - where to find them: continued

The **iterator protocol is a way in which an object should behave to conform to the rules imposed by the context of the `for` and `in` statements**. An object conforming to the iterator protocol is called an **iterator**.

An iterator must provide two methods:

- `__iter__()` which should **return the object itself** and which is invoked once (it's needed for Python to successfully start the iteration)
- `__next__()` which is intended to **return the next value** (first, second, and so on) of the desired series - it will be invoked by the `for`/`in` statements in order to pass through the next iteration; if there are no more values to provide, the method should **raise the `StopIteration` exception**.

Does it sound strange? Not at all. Look at the example in the editor.

We've built a class able to iterate through the first `n` values (where `n` is a constructor parameter) of the Fibonacci numbers.

```python
class Fib:
    def __init__(self, nn):
        print("__init__")
        self.__n = nn
        self.__i = 0
        self.__p1 = self.__p2 = 1

    def __iter__(self):
        print("__iter__")
        return self

    def __next__(self):
        print("__next__")				
        self.__i += 1
        if self.__i > self.__n:
            raise StopIteration
        if self.__i in [1, 2]:
            return 1
        ret = self.__p1 + self.__p2
        self.__p1, self.__p2 = self.__p2, ret
        return ret


for i in Fib(10):
    print(i)

```

### Generator - Yield

We've added `yield` instead of `return`. This little amendment **turns the function into a generator**, and executing the `yield` statement has some very interesting effects.

First of all, it provides the value of the expression specified after the `yield` keyword, just like `return`, but doesn't lose the state of the function.

All the variables' values are frozen, and wait for the next invocation, when the execution is resumed (not taken from scratch, like after `return`).

There is one important limitation: such a **function should not be invoked explicitly** as - in fact - it isn't a function anymore; **it's a generator object**.

The invocation will **return the object's identifier**, not the series we expect from the generator.

Due to the same reasons, the previous function (the one with the `return` statement) may only be invoked explicitly, and must not be used as a generator.

The `yield` statement suspends function execution and causes the function to return the yield's argument as a result. Such a function cannot be invoked in a regular way – its only purpose is to be used as a **generator** (i.e. in a context that requires a series of values, like a `for` loop.)

```python
def fun(n):
    yield from range(n):

for v in fun(5):
    print(v)
```

### List comprehension

A **list comprehension** becomes a **generator** when used inside **parentheses** (used inside brackets, it produces a regular list). For example:

```
for x in (el * 2 for el in range(5)):
	print(x)
```

### The lambda function

The `lambda` function is a concept borrowed from mathematics, more specifically, from a part called *the Lambda calculus*, but these two phenomena are not the same.

```
lambda parameters: expression 
```

Such a clause **returns the value of the expression when taking into account the current value of the current `lambda` argument**.

As usual, an example will be helpful. Our example uses three `lambda` functions, but gives them names. Look at it carefully:

```python
two = lambda: 2 
sqr = lambda x: x * x 
pwr = lambda x, y: x ** y 
for a in range(-2, 3):
	print(sqr(a), end=" ")
    print(pwr(a, two())) 
```

```python
def print_function(args, fun):
    for x in args:
        print('f(', x,')=', fun(x), sep='')

print_function([x for x in range(-2, 3)], lambda x: 2 * x**2 - 4 * x + 2)
```

### Lambdas and the map() function

In the simplest of all possible cases, the `map()` function:

```
map(function, list) 
```

The above description is extremely simplified, as:

- the second `map()` argument may be any entity that can be iterated (e.g., a tuple, or just a generator)
- `map()` can accept more than two arguments.

The `map()` function applies the function passed by its first argument to all its second argument's elements, and returns an iterator delivering all subsequent function results.

### Lambdas and the filter() function

Another Python function which can be significantly beautified by the application of a lambda is `filter()`.

It expects the same kind of arguments as `map()`, but does something different - it **filters its second argument while being guided by directions flowing from the function specified as the first argument** (the function is invoked for each list element, just like in `map()`).

The elements which return `True` from the function **pass the filter** - the others are rejected.

The example in the editor shows the `filter()` function in action.

```python
from random import  randint

data = [randint(-10,10) for x in range(5)]
filtered = list(filter(lambda x: x > 0 and x % 2 == 0, data))

print(data)
print(filtered)
```

# File Streaming

here are two basic operations performed on the stream:

- **read** from the stream: the portions of the data are retrieved from the file and placed in a memory area managed by the program (e.g., a variable);
- **write** to the stream: the portions of the data from the memory (e.g., a variable) are transferred to the file.

There are three basic modes used to open the stream:

- **read mode**: a stream opened in this mode allows **read operations only**; trying to write to the stream will cause an exception (the exception is named UnsupportedOperation, which inherits OSError and ValueError, and comes from the io module);
- **write mode**: a stream opened in this mode allows **write operations only**; attempting to read the stream will cause the exception mentioned above;
- **update mode**: a stream opened in this mode allows **both writes and reads**.

____

## Opening the streams: modes

`r` open mode: read

- the stream will be opened in **read mode**;
- the file associated with the stream **must exist** and has to be readable, otherwise the `open()` function raises an exception.

`w` open mode: write

- the stream will be opened in **write mode**;
- the file associated with the stream **doesn't need to exist**; if it doesn't exist it will be created; if it exists, it will be truncated to the length of zero (erased); if the creation isn't possible (e.g., due to system permissions) the `open()` function raises an exception.

`a` open mode: append

- the stream will be opened in **append mode**;
- the file associated with the stream **doesn't need to exist**; if it doesn't exist, it will be created; if it exists the virtual recording head will be set at the end of the file (the previous content of the file remains untouched.)

`r+` open mode: read and update

- the stream will be opened in **read and update mode**;
- the file associated with the stream **must exist and has to be writeable**, otherwise the `open()` function raises an exception;
- both read and write operations are allowed for the stream.

`w+` open mode: write and update

- the stream will be opened in **write and update** mode;
- the file associated with the stream **doesn't need to exist**; if it doesn't exist, it will be created; the previous content of the file remains untouched;
- both read and write operations are allowed for the stream.

## Selecting text and binary modes

If there is a letter `b` at the end of the mode string it means that the stream is to be opened in the **binary mode**.

If the mode string ends with a letter `t` the stream is opened in the **text mode**.

Text mode is the default behaviour assumed when no binary/text mode specifier is used.

Finally, the successful opening of the file will set the current file position (the virtual reading/writing head) before the first byte of the file **if the mode is not `a`** and after the last byte of file **if the mode is set to `a`**.



| Text mode | Binary mode | Description      |
| :-------: | :---------: | :--------------- |
|   `rt`    |    `rb`     | read             |
|   `wt`    |    `wb`     | write            |
|   `at`    |    `ab`     | append           |
|   `r+t`   |    `r+b`    | read and update  |
|   `w+t`   |    `w+b`    | write and update |

#### Key takeaways

1. To read a file’s contents, the following stream methods can be used:

- `read(number)` – reads the `number` characters/bytes from the file and returns them as a string; is able to read the whole file at once;
- `readline()` – reads a single line from the text file;
- `readlines(number)` – reads the `number` lines from the text file; is able to read all lines at once;
- `readinto(bytearray)` – reads the bytes from the file and fills the `bytearray` with them;

2. To write new content into a file, the following stream methods can be used:

- `write(string)` – writes a `string` to a text file;
- `write(bytearray)` – writes all the bytes of `bytearray` to a file;

# OS module

- Unix-like systems:

  `mkdir -p my_first_directory/my_second_directory`

- Windows:

  `mkdir my_first_directory/my_second_directory`

```python
import os

os.makedirs("my_first_directory/my_second_directory")
os.chdir("my_first_directory")
print(os.getcwd())
os.chdir("my_second_directory")
print(os.getcwd())

os.removedirs("my_first_directory/my_second_directory")
print(os.listdir())
```

### Main Takeaways

3. The `mkdir` function creates a directory in the path passed as its argument. The path can be either relative or absolute, e.g:

```
import os os.mkdir("hello") # the relative path os.mkdir("/home/python/hello") # the absolute path 
```

**Note**: If the directory exists, a `FileExistsError` exception will be thrown. In addition to the `mkdir` function, the `os` module provides the `makedirs` function, which allows you to recursively create all directories in a path.

4. The result of the `listdir()` function is a list containing the names of the files and directories that are in the path passed as its argument.

It's important to remember that the `listdir` function omits the entries '.' and '..', which are displayed, for example, when using the `ls -a` command on Unix systems. If the path isn't passed, the result will be returned for the current working directory.

5. To move between directories, you can use a function called `chdir()`, which changes the current working directory to the specified path. As its argument, it takes any relative or absolute path.

If you want to find out what the current working directory is, you can use the `getcwd()` function, which returns the path to it.

6. To remove a directory, you can use the `rmdir()` function, but to remove a directory and its subdirectories, use the `removedirs()` function.

7. On both Unix and Windows, you can use the system function, which executes a command passed to it as a string, e.g.:

```
import os returned_value = os.system("mkdir hello") 
```

The system function on Windows returns the value returned by shell after running the command given, while on Unix it returns the exit status of the process.

# Introduction to the datetime module

The `datetime` module provides several methods to create a `date` object. One of them is the `fromisoformat` method, which takes a date in the **YYYY-MM-DD** format compliant with the ISO 8601 standard.

#### Creating time objects

You already know how to present a date using the `date` object. The `datetime` module also has a class that allows you to present time. Can you guess its name? Yes, it's called `time`:

```
time(hour, minute, second, microsecond, *tzinfo, fold*)
```

#### The asctime() and mktime() functions

The first of the functions, called `asctime`, converts a *struct_time* object or a tuple to a string. Note that the familiar `gmtime` function is used to get the *struct_time* object. If you don't provide an argument to the `asctime` function, the time returned by the `localtime` function will be used.

The second function called `mktime` converts a *struct_time* object or a tuple that expresses the local time to the number of seconds since the Unix epoch.

```
import time

timestamp = 1572879180
st = time.gmtime(timestamp)

print(time.asctime(st))
print(time.mktime((2019, 11, 4, 14, 53, 0, 0, 308, 0)))
```

#### Timestamp

```
from datetime import datetime

dt = datetime(2020, 10, 4, 14, 55)
print("Timestamp:", dt.timestamp())
```

#### Date and time formatting (part 1)

All `datetime` module classes presented so far have a method called `strftime`. This is a very important method, because it allows us to return the date and time in the format we specify.

The `strftime` method takes only one argument in the form of a string specifying the format that can consist of directives.

```py
from datetime import time
from datetime import datetime

d = date(2020, 1, 4)
print(d.strftime('%Y/%m/%d'))

t = time(14, 53)
print(t.strftime("%H:%M:%S"))

dt = datetime(2020, 11, 4, 14, 53)
print(dt.strftime("%y/%B/%d %H:%M:%S"))
```

**Note:** You can find all available directives [here](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes).

#### The strftime() function in the time module

```python
import time

timestamp = 1572879180
st = time.gmtime(timestamp)

print(time.strftime("%Y/%m/%d %H:%M:%S", st))
print(time.strftime("%Y/%m/%d %H:%M:%S"))
```

#### Date and time operations

```python
from datetime import date
from datetime import datetime

d1 = date(2020, 11, 4)
d2 = date(2019, 11, 4)

print(d1 - d2)

dt1 = datetime(2020, 11, 4, 0, 0, 0)
dt2 = datetime(2019, 11, 4, 14, 53, 0)

print(dt1 - dt2)
```

